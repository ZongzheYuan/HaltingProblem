@Misc{agda,
  author = {{Agda~team}},
  title = {Agda},
  year = 2009,
  note = {\url{http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php}}
}

@article{Turing,
  title={On computable numbers, with an application to the Entscheidungsproblem},
  author={Turing, Alan Mathison},
  journal={J. of Math},
  volume={58},
  number={345-363},
  pages={5},
  year={1936}
}

@article{turing_computable_1936,
	title = {On computable numbers, with an application to the {Entscheidungsproblem}},
	volume = {58},
	url = {https://people.cs.umass.edu/~immerman/cs601/TuringPaper1936.pdf},
	number = {345-363},
	urldate = {2016-03-11},
	journal = {J. of Math},
	author = {Turing, Alan Mathison},
	year = {1936},
	pages = {5},
	file = {Turing_Paper_1936.pdf:/Users/silenceyuan/Dropbox/文献/storage/UK5IXZ92/Turing_Paper_1936.pdf:application/pdf}
}

@article{copeland_church-turing_2002,
	title = {The church-turing thesis},
	journal = {Stanford encyclopedia of philosophy},
	author = {Copeland, B. Jack},
	year = {2002},
	file = {Church-Turing.pdf:/Users/silenceyuan/Dropbox/文献/storage/6N4WC5WN/Church-Turing.pdf:application/pdf}
}

@article{church_unsolvable_1936,
	title = {An unsolvable problem of elementary number theory},
	volume = {58},
	url = {http://www.jstor.org/stable/2371045},
	number = {2},
	urldate = {2016-03-12},
	journal = {American journal of mathematics},
	author = {Church, Alonzo},
	year = {1936},
	pages = {345--363},
	file = {church.pdf:/Users/silenceyuan/Dropbox/文献/storage/64BTBPNW/church.pdf:application/pdf}
}

@book{rogers_theory_1987,
	address = {Cambridge, Mass},
	edition = {1st MIT Press pbk. ed},
	title = {Theory of recursive functions and effective computability},
	isbn = {978-0-262-68052-3},
	publisher = {MIT Press},
	author = {Rogers, H.},
	year = {1987},
	keywords = {Computable functions, Recursive functions}
}

@book{yasuhara_recursive_1971,
	address = {New York},
	series = {Computer science and applied mathematics},
	title = {Recursive function theory and logic},
	isbn = {978-0-12-768950-0},
	publisher = {Academic Press},
	author = {Yasuhara, Ann},
	year = {1971},
	keywords = {Logic, Symbolic and mathematical, Recursive functions}
}

@book{moggi_computational_1988,
	title = {Computational lambda-calculus and monads},
	url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.80.3104&rep=rep1&type=pdf},
	urldate = {2015-10-12},
	publisher = {Citeseer},
	author = {Moggi, Eugenio},
	year = {1988},
	file = {10.1.1.80.3104.pdf:/Users/silenceyuan/Dropbox/文献/storage/WU7DMR78/10.1.1.80.3104.pdf:application/pdf}
}

@inproceedings{cook_time-bounded_1972,
	title = {Time-bounded random access machines},
	url = {http://dl.acm.org/citation.cfm?id=804898},
	urldate = {2015-10-12},
	booktitle = {Proceedings of the fourth annual {ACM} symposium on {Theory} of computing},
	publisher = {ACM},
	author = {Cook, Stephen A. and Reckhow, Robert A.},
	year = {1972},
	pages = {73--80},
	file = {p73-cook.pdf:/Users/silenceyuan/Dropbox/文献/storage/9J4B4J7C/p73-cook.pdf:application/pdf}
}

@misc{markov_2015,
	title = {Markov algorithm},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Markov_algorithm&oldid=680734144},
	abstract = {In theoretical computer science, a Markov algorithm is a string rewriting system that uses grammar-like rules to operate on strings of symbols. Markov algorithms have been shown to be Turing-complete, which means that they are suitable as a general model of computation and can represent any mathematical expression from its simple notation. Markov algorithms are named after the Soviet mathematician Andrey Markov, Jr.
Refal is a programming language based on Markov algorithms.},
	language = {en},
	urldate = {2015-12-08},
	journal = {Wikipedia, the free encyclopedia},
	month = sep,
	year = {2015},
	note = {Page Version ID: 680734144},
	file = {Snapshot:/Users/silenceyuan/Dropbox/文献/storage/ZEP66FGA/index.html:text/html}
}

@misc{recursive_2015,
	title = {Recursive language},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Recursive_language&oldid=692264552},
	abstract = {In mathematics, logic and computer science, a formal language (a set of finite sequences of symbols taken from a fixed alphabet) is called recursive if it is a recursive subset of the set of all possible finite sequences over the alphabet of the language. Equivalently, a formal language is recursive if there exists a total Turing machine (a Turing machine that halts for every given input) that, when given a finite sequence of symbols as input, accepts it if belongs to the language and rejects it otherwise. Recursive languages are also called decidable.
The concept of decidability may be extended to other models of computation. For example one may speak of languages decidable on a non-deterministic Turing machine. Therefore, whenever an ambiguity is possible, the synonym for "recursive language" used is Turing-decidable language, rather than simply decidable.
The class of all recursive languages is often called R, although this name is also used for the class RP.
This type of language was not defined in the Chomsky hierarchy of (Chomsky 1959). All recursive languages are also recursively enumerable. All regular, context-free and context-sensitive languages are recursive.},
	language = {en},
	urldate = {2016-03-14},
	journal = {Wikipedia, the free encyclopedia},
	month = nov,
	year = {2015},
	note = {Page Version ID: 692264552},
	file = {Snapshot:/Users/silenceyuan/Dropbox/文献/storage/6RTDI22K/index.html:text/html}
}

@misc{universal_2016,
	title = {Universal {Turing} machine},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Universal_Turing_machine&oldid=709735601},
	abstract = {In computer science, a universal Turing machine (UTM) is a Turing machine that can simulate an arbitrary Turing machine on arbitrary input. The universal machine essentially achieves this by reading both the description of the machine to be simulated as well as the input thereof from its own tape. Alan Turing introduced this machine in 1936–1937. This model is considered by some (for example, Martin Davis (2000)) to be the origin of the stored program computer—used by John von Neumann (1946) for the "Electronic Computing Instrument" that now bears von Neumann's name: the von Neumann architecture. It is also known as universal computing machine, universal machine (UM), machine U, U.
In terms of computational complexity, a multi-tape universal Turing machine need only be slower by logarithmic factor compared to the machines it simulates.},
	language = {en},
	urldate = {2016-03-14},
	journal = {Wikipedia, the free encyclopedia},
	month = mar,
	year = {2016},
	note = {Page Version ID: 709735601},
	file = {Snapshot:/Users/silenceyuan/Dropbox/文献/storage/J9UAX7GM/index.html:text/html}
}

@book{jones_computability_1997,
	address = {Cambridge, Mass},
	series = {Foundations of computing},
	title = {Computability and complexity: from a programming perspective},
	isbn = {978-0-262-10064-9},
	shorttitle = {Computability and complexity},
	publisher = {MIT Press},
	author = {Jones, Neil D.},
	year = {1997},
	keywords = {Computational complexity, Computer programming}
}

@misc{recursively_2015,
	title = {Recursively enumerable language},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Recursively_enumerable_language&oldid=678743023},
	abstract = {In mathematics, logic and computer science, a formal language is called recursively enumerable (also recognizable, partially decidable, semidecidable, Turing-acceptable or Turing-recognizable) if it is a recursively enumerable subset in the set of all possible words over the alphabet of the language, i.e., if there exists a Turing machine which will enumerate all valid strings of the language.
Recursively enumerable languages are known as type-0 languages in the Chomsky hierarchy of formal languages. All regular, context-free, context-sensitive and recursive languages are recursively enumerable.
The class of all recursively enumerable languages is called RE.},
	language = {en},
	urldate = {2016-03-14},
	journal = {Wikipedia, the free encyclopedia},
	month = aug,
	year = {2015},
	note = {Page Version ID: 678743023},
	file = {Snapshot:/Users/silenceyuan/Dropbox/文献/storage/XF4R29CF/index.html:text/html}
}

@misc{halting_2015,
	title = {Halting problem},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Halting_problem&oldid=685183096},
	abstract = {In computability theory, the halting problem is the problem of determining, from a description of an arbitrary computer program and an input, whether the program will finish running or continue to run forever.
Alan Turing proved in 1936 that a general algorithm to solve the halting problem for all possible program-input pairs cannot exist. A key part of the proof was a mathematical definition of a computer and program, which became known as a Turing machine; the halting problem is undecidable over Turing machines. It is one of the first examples of a decision problem.
Jack Copeland (2004) attributes the term halting problem to Martin Davis.},
	language = {en},
	urldate = {2015-10-12},
	journal = {Wikipedia, the free encyclopedia},
	month = oct,
	year = {2015},
	note = {Page Version ID: 685183096},
	file = {Snapshot:/Users/silenceyuan/Dropbox/文献/storage/58RHQZ5J/index.html:text/html}
}

@book{van_oosten_homotopy_2014,
	title = {Homotopy {Type} {Theory}: {Univalent} {Foundations} of {Mathematics}, http://homotopytypetheory. org/book, {Institute} for {Advanced} {Study}},
	shorttitle = {Homotopy {Type} {Theory}},
	url = {http://www.jstor.org/stable/43150546},
	urldate = {2016-03-12},
	publisher = {JSTOR},
	author = {van Oosten, Jaap},
	year = {2014},
	file = {43150546.pdf:/Users/silenceyuan/Dropbox/文献/storage/JZBGI9AP/43150546.pdf:application/pdf}
}

@incollection{norell_dependently_2009,
	title = {Dependently typed programming in {Agda}},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-04652-0_5},
	urldate = {2015-10-12},
	booktitle = {Advanced {Functional} {Programming}},
	publisher = {Springer},
	author = {Norell, Ulf},
	year = {2009},
	pages = {230--266},
	file = {tutorial.pdf:/Users/silenceyuan/Dropbox/文献/storage/CET49IKZ/tutorial.pdf:application/pdf}
}

@article{boyer_mechanical_1984,
	title = {A mechanical proof of the unsolvability of the halting problem},
	volume = {31},
	url = {http://dl.acm.org/citation.cfm?id=1882},
	number = {3},
	urldate = {2016-03-09},
	journal = {Journal of the ACM (JACM)},
	author = {Boyer, Robert S. and Moore, J. Strother},
	year = {1984},
	pages = {441--458},
	file = {p441-boyer.pdf:/Users/silenceyuan/Dropbox/文献/storage/KSIR2WBF/p441-boyer.pdf:application/pdf}
}
